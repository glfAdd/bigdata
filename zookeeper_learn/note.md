##### 特点

- ZooKeeper 将数据保存在内存中，这也就保证了高吞吐量和低延迟, 能够存储的容量不太大
- ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态

##### session
- Session 指的是 ZooKeeper 服务器与客户端会话, 是指客户端和服务器之间的一个 TCP 长连接。
- 客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。 
- Session的sessionTimeout值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。
- 在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。

##### Znode

- 在Zookeeper中，“节点"分为两类，
  - 机器节点: 构成集群的机器
  - ZNode: 数据模型中的数据单元
- node可以分为持久节点和临时节点两类
  - 持久节点: 一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。
  - 临时节点: 它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。
- ZooKeeper还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL.一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。





##### 集群高可用

- 客户端随机连接集群中任何一台server, 集群内所有server基于Zab(ZooKeeper Atomic Broadcast)协议进行通信, 集群内部根据算法自动选举出一个leader，负责向follower(其他 server)广播所有变化消息
-  集群中每个follower都和leader通信
-  Follower接收来自leader的所有变化消息，保存在自己内存
- Follower转发来自客户端的写请求给leader
- 客户端的读请求会在follower端直接服务，无需转发给leader

- Leader: Leader服务器是zk集群工作机制的核心, 事务请求的唯一调度者和处理者,保证集群事务请求处理的顺序性.
- Observer
  Observer是一种新型的zk节点,Observer服务器只提供非事务服务.通常用于不影响集群事务处理能力的前提下提升集群的非事务的处理能力,Observer有另外一个优势，因为它不参与投票，所以他们不属于zk集群的关键部位，即使他们Failed，或者从集群中断开，也不会影响集群的可用性。



有序性: zk给每次更新附加一个数字标签，表明zk中的事务顺序，后续操作可以利用这个顺序来完成更高层次的抽象功能，例如同步原语操作。
高性能: zk特别适合于以读为主要负荷的场合。zk可以运行在数千台机器上，如果大部分操作为读，例如读写比例为10:1，zk的效率会很高。






zk中有几种节点类型(节点类型在节点创建的时候就被确定且不可改变)
    临时节点（EPHEMERAL）：临时创建的，会话结束节点自动被删除，也可以手动删除，临时节点不能拥有子节点.
    持久节点（PERSISTENT）：创建后永久存在，除非主动删除。
    临时顺序节点（EPHEMERAL_SEQUENTIAL）：具有临时节点特征，但是它会有序列号。
    持久顺序节点（PERSISTENT_SEQUENTIAL）：具有持久节点特征，但是它会有序列号。
    容器节点(CONTAINER)：如果节点中最后一个子Znode被删除，将会触发删除该Znode；
    持久定时节点(PERSISTENT_WITH_TTL)：客户端断开连接后不会自动删除Znode，如果该Znode没有子Znode且在给定TTL时间内无修改，该Znode将会被删除；TTL单位是毫秒，必须大于0且小于或等于 EphemeralType.MAX_TTL
    持久顺序定时节点(PERSISTENT_SEQUENTIAL_WITH_TTL)：同PERSISTENT_WITH_TTL，且Znode命名末尾自动添加递增编号；


节点信息, 每一个Znode都有对应的stat结构，和文件系统类似。stat状态主要包含下面的信息：
    cZxid. 节点被创建时候的事务ID
    mZxid 节点最后一次被修改时候的事务ID
    pZxid 该节点的子节点最后一次被修改时的事务ID。子节点删除或添加才会影响pZxid
    ctime 节点被创建的时间
    mtime 节点被修改的世界
    dataVersion 这个节点数据改变的次数
    cversion 子节点被改变的次数
    aclVersion 节点的ACL(访问控制列表被改变的次数)
    ephemeralOwner 创建该临时节点的 session ID。如果是持久节点，设置为0
    dataLength 数据内容长度
    numChildren 当前节点子节点的个数

zookeeper特性
顺序一致性: 客户端的更新顺序与它们被发送的顺序一致。
原子性: 更新操作要么成功，要么失败，没有第三种结果。
单系统映像: 无论客户端连接到哪一个服务器，他都将看到相同的zk视图。
可靠性: 一旦一个更新操作被应用，那么在客户端再次更新之前，其值不会再改变。
实时性: zk保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。 
    但由于网络延时等原因，zk不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。